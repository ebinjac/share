import ldap, {
    Client, // Import Client type
    ClientOptions, // Import ClientOptions
    SearchOptions, // Import SearchOptions
    SearchEntry, // Import SearchEntry (we'll get the object from this)
    LDAPResult, // Import LDAPResult for search end status
    escapeFilter, // Import escapeFilter explicitly
    Error as LdapError, // Import LdapError base class (or specific errors if known/exported)
    InvalidCredentialsError // Import specific error type if available
} from 'ldapjs';
import { TlsOptions } from 'tls'; // Standard Node TLS options
import fs from 'fs'; // Needed if using file paths for TLS certs

// Define a stricter type for the expected LDAP user attributes *after* retrieval
// We use `unknown` initially and then validate/cast.
type LdapEntryObject = Record<string, unknown>;

// Interface for the final user object returned by the function
interface LdapUser {
    dn: string;
    uid: string;
    cn: string;
    mail?: string; // Mail is optional
    groups: string[]; // Array of group Common Names (CNs)
}

// Helper to extract CN from a DN string (e.g., "cn=Admins,ou=Groups,dc=..." -> "Admins")
function getCnFromDn(dn: string): string | null {
    // Use a case-insensitive match
    const match = dn.match(/cn=([^,]+)/i);
    return match ? match[1] : null;
}

// Helper to safely get a string attribute from the LDAP entry object
function getStringAttr(entry: LdapEntryObject, attrName: string): string | undefined {
    const value = entry[attrName];
    if (typeof value === 'string' && value.length > 0) {
        return value;
    }
    return undefined;
}

// Helper to safely get the 'memberOf' groups (handles missing, string, string[])
function getGroupDns(entry: LdapEntryObject, groupAttribute: string): string[] {
    const value = entry[groupAttribute];
    if (typeof value === 'string') {
        return [value]; // Single group membership
    }
    if (Array.isArray(value)) {
        // Filter out any non-string elements just in case
        return value.filter((item): item is string => typeof item === 'string');
    }
    return []; // No groups found or attribute has unexpected type
}


export async function authenticateLdap(username: string, password: string): Promise<LdapUser | null> {

    // --- Configuration with Safety Checks ---
    const ldapUrl = process.env.LDAP_SERVER_URL;
    const bindDn = process.env.LDAP_BIND_DN;
    const bindCredentials = process.env.LDAP_BIND_CREDENTIALS;
    const searchBase = process.env.LDAP_USER_SEARCH_BASE || process.env.LDAP_BASE_DN;
    const groupAttribute = process.env.LDAP_GROUP_ATTRIBUTE || 'memberOf';
    let searchFilterTemplate = process.env.LDAP_USER_SEARCH_FILTER || '(uid={{username}})';

    if (!ldapUrl || !bindDn || !bindCredentials || !searchBase) {
        console.error("LDAP Error: Missing required environment variables (URL, Bind DN, Bind Credentials, Search Base).");
        throw new Error("LDAP configuration is incomplete.");
    }

    // Escape username and create final filter
    const escapedUsername = escapeFilter(username);
    const searchFilter = searchFilterTemplate.replace('{{username}}', escapedUsername);

    // --- TLS Configuration ---
    const tlsOptions: TlsOptions = {};
    if (ldapUrl.startsWith('ldaps')) {
        // For production, configure proper CA certs, etc.
        // Example:
        // if (process.env.LDAP_CA_CERT_PATH) {
        //   try {
        //     tlsOptions.ca = [fs.readFileSync(process.env.LDAP_CA_CERT_PATH)];
        //   } catch (e) {
        //      console.error(`LDAP TLS Error: Could not read CA cert at ${process.env.LDAP_CA_CERT_PATH}`, e);
        //      throw new Error("Failed to configure LDAP TLS.");
        //   }
        // }

        // For development with self-signed certs: **NEVER use in Production!**
        if (process.env.NODE_ENV === 'development') {
            console.warn('LDAP TLS Warning: Using rejectUnauthorized: false for LDAPS in development. DO NOT use in production without proper CA validation.');
            tlsOptions.rejectUnauthorized = false;
        } else if (!tlsOptions.ca && !process.env.LDAP_SKIP_TLS_VERIFY) { // Add an env var to explicitly skip verification if needed, but discourage it
             console.error("LDAP TLS Error: Attempting LDAPS in non-development environment without CA certificate or explicit skip. Set LDAP_CA_CERT_PATH or LDAP_SKIP_TLS_VERIFY=true (not recommended).");
             throw new Error("LDAPS TLS configuration error.");
        }
    }

    // --- Client Setup ---
    const clientOptions: ClientOptions = {
        url: [ldapUrl], // url expects an array
        tlsOptions: Object.keys(tlsOptions).length > 0 ? tlsOptions : undefined, // Only add if configured
        connectTimeout: parseInt(process.env.LDAP_CONNECT_TIMEOUT || '5000', 10), // 5 seconds default
        reconnect: false, // Disable auto-reconnect for auth clarity
    };
    const client: Client = ldap.createClient(clientOptions);
    let userDn: string | undefined = undefined; // Store the found user DN

    // --- Promisified Operations ---
    const bindAsync = (dn: string, creds: string): Promise<void> => new Promise((resolve, reject) => {
        client.bind(dn, creds, (err) => {
            if (err) {
                console.error(`LDAP Bind Error for DN [${dn}]:`, err.message);
                reject(err); // Reject with LdapError
            } else {
                // console.log(`LDAP Bind successful for DN [${dn}]`); // Less verbose logging
                resolve();
            }
        });
    });

    const searchAsync = (base: string, opts: SearchOptions): Promise<LdapEntryObject[]> => new Promise((resolve, reject) => {
        const entries: LdapEntryObject[] = [];
        client.search(base, opts, (err, res) => {
            if (err) {
                console.error('LDAP Search Initiation Error:', err.message);
                return reject(err); // Reject with LdapError
            }
            res.on('searchEntry', (entry: SearchEntry) => { // Explicit type for entry
                // Push the plain object representation
                entries.push(entry.object);
            });
            res.on('error', (searchErr: LdapError) => { // Explicit type for error
                console.error('LDAP Search Stream Error:', searchErr.message);
                // Don't reject here if end has already been called or if it's just a close notification
                // Let the 'end' event handle final status check.
                // reject(searchErr); // Avoid rejecting here, wait for 'end'
            });
            res.on('end', (result: LDAPResult | null) => { // Explicit type for result
                if (result?.status !== 0) {
                    const errMsg = `LDAP search failed: ${result?.errorMessage || 'Unknown error'} (Status: ${result?.status})`;
                    console.error(errMsg);
                    // Only reject if no entries were found AND there was an error status
                    if (entries.length === 0) {
                       reject(new Error(errMsg)); // Reject with generic Error or custom one
                    } else {
                       console.warn(`LDAP search ended with status ${result.status} but ${entries.length} entries were found. Resolving with found entries.`);
                       resolve(entries); // Resolve with what we found, despite non-zero status
                    }
                } else {
                    resolve(entries); // Success
                }
            });
        });
    });

    const unbindAsync = (): Promise<void> => new Promise((resolve, reject) => {
        // Check if client is still connected before unbinding
        // Note: ldapjs client doesn't have a simple 'isConnected' property.
        // Unbinding a disconnected client might error or do nothing gracefully.
        client.unbind(err => {
            if (err) {
                // Don't reject on errors like "Client connection closed" if unbinding during cleanup
                console.warn("LDAP Unbind Warning:", err.message); // Log non-critical errors
                resolve(); // Resolve anyway during cleanup
            } else {
                 // console.log("LDAP Unbind successful.");
                resolve();
            }
        });
    });


    // --- Authentication Flow ---
    try {
        // 1. Bind with the service account to search for the user
        await bindAsync(bindDn, bindCredentials);
        console.log(`LDAP: Service account bind successful.`);

        // 2. Search for the user
        const searchOptions: SearchOptions = {
            filter: searchFilter,
            scope: 'sub',
            attributes: ['dn', 'uid', 'cn', 'sn', 'mail', groupAttribute], // Specify attributes
            sizeLimit: 1 // Expect only one user
        };

        console.log(`LDAP: Searching for user with filter "${searchFilter}" under base "${searchBase}"`);
        const users = await searchAsync(searchBase, searchOptions);

        if (users.length === 0) {
            console.log(`LDAP: User "${username}" not found with filter "${searchFilter}".`);
            // Return null for failed auth (user not found), not an error throw
            return null;
        }
        // We requested sizeLimit: 1, so users.length > 1 shouldn't happen, but good practice:
        if (users.length > 1) {
            console.warn(`LDAP: Multiple users found for filter "${searchFilter}". Using the first one.`);
        }

        const userEntry = users[0]; // Type is LdapEntryObject (Record<string, unknown>)

        // --- Safely Extract Attributes ---
        userDn = getStringAttr(userEntry, 'dn'); // Get the user's full DN
        const uid = getStringAttr(userEntry, 'uid');
        const cn = getStringAttr(userEntry, 'cn');
        const mail = getStringAttr(userEntry, 'mail'); // Optional

        if (!userDn || !uid) {
            console.error(`LDAP Error: Found entry for "${username}" is missing required attributes 'dn' or 'uid'. Entry:`, userEntry);
            throw new Error(`LDAP entry for user ${username} is incomplete.`);
        }
        console.log(`LDAP: Found user DN: ${userDn}`);

        // (Optional) Unbind service account if needed before binding as user (often not required)
        // await unbindAsync();

        // 3. Attempt to bind as the found user to verify password
        console.log(`LDAP: Attempting bind as user "${userDn}" to verify password...`);
        await bindAsync(userDn, password);
        console.log(`LDAP: User "${username}" authenticated successfully.`);

        // 4. Extract group information safely
        const groupDns = getGroupDns(userEntry, groupAttribute);
        console.log(`LDAP: Raw Group DNs for user "${username}":`, groupDns);

        // Extract Common Names (CN) from group DNs
        const groupCns = groupDns.map(dn => getCnFromDn(dn)).filter((cn): cn is string => cn !== null);
        console.log(`LDAP: Extracted Group CNs for user "${username}":`, groupCns);

        // 5. Construct the final user object for next-auth
        const finalUser: LdapUser = {
            dn: userDn,
            uid: uid,
            cn: cn || uid, // Fallback to uid if cn is missing
            mail: mail, // Assign mail if found, otherwise undefined (matches interface)
            groups: groupCns,
        };

        return finalUser; // Authentication successful

    } catch (error) {
        console.error('LDAP Authentication Process Failed:', error); // Log the actual error

        // Check for specific LDAP error types if possible and exported by @types/ldapjs
        // Using instanceof is safer than checking 'name' strings.
        if (error instanceof InvalidCredentialsError) {
             console.log(`LDAP: Invalid credentials provided for user "${username}" (DN: ${userDn || 'N/A'}).`);
             return null; // Signal failed authentication (bad password)
        }
        // Catch other LdapError types if needed, e.g., OperationsError, TimeoutError

        // Check common error names/messages as a fallback if specific types aren't available/reliable
        if (error instanceof Error) { // Check it's an Error object
             if (error.name === 'InvalidCredentialsError' ||
                 (error as any).lde_message?.includes('Invalid Credentials')) // Check lde_message if it exists
             {
                  console.log(`LDAP: Invalid credentials provided for user "${username}" (DN: ${userDn || 'N/A'}).`);
                 return null; // Signal failed authentication (bad password)
             }
        }

        // For other errors (connection, search error, config error, etc.),
        // returning null might hide underlying issues from the caller (`authorize` function).
        // Consider throwing a generic error or a specific error to be caught in `authorize`.
        // Let's return null for now to simplify the `authorize` function handling.
        return null; // Indicate generic failure to authorize function

    } finally {
        // 6. Always attempt to unbind the client
        if (client) {
            // console.log("LDAP: Cleaning up client connection.");
            await unbindAsync();
        }
    }
}
